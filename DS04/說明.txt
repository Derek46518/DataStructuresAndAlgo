任務一
簡介 :讀入一個binary檔，裡面有發訊者學號、收訊者學號以及權重。讀入資料後用這些資料建立一個相鄰串列，並且必須包含所有發訊者以及從未發訊的收訊者學號。最後主陣列依照發訊者學號由小到大排序，並寫成檔案

方法 :每取得一組資料，就去尋找相鄰串列有沒有該發訊者點和收訊者點，若沒有則新增一個放進相鄰串列。並且讓發訊者後面接的串列新增收訊者的點，以及設定權重為該筆資料的權重。最後再將這些資料利用內建的排序排好，輸出成檔案。

任務二
簡介 :利用任務一所建立的相鄰串列，從每個發訊者學號出發，透過BFS演算法找出所有相異的點，並記錄起來。最後依照發訊者學號的連通數由大到小排序，若一樣則以學號由小到大，並輸出成檔案。


方法 :用一個unordered_set去存走訪過的節點(因為unordered_set確認是否存在的演算法接近O(1)，因此採用。)。以及用一個queue去存要走訪的節點。每pop一個點，就去找該點的收訊者，並且將沒走訪過的放入unordered_set和queue。
以相鄰串列的每個點當作開始，執行上述方法，得到所有相鄰串列上的點的通道數，就可以進行排序，並且寫檔。

心得
這次我學會了如何在 C++ 使用 Lambda Expression ，此方法幫助我套用內建的sort，而不用針對每個資料結構寫出不同的 sort 。並且我還在此學到了unordered_set 怎麼應用。 unordered_set 用到了上次作業的 hash，因此可以將時間複雜度從原本使用 vector 時的 O(n) 降低至接近 O(1) 。使速度快上了不少。最後，因為要處理權重的問題，我上網查到 pair ，這樣就不怕排序的時候讓資料對應跑掉。

